/*
 Это данные, которые будут заливаться в EEPROM или AT24C32(64)
 Формат файла подобен .c:
   INT8 name : <значение>;
 где:

   INT8
      - тип данных из списка возможных:
      CHAR
         - символ (один байт), например 'A' или 255;
      INT8, INT16, INT32
         - целое (не важно sined или unsined) 1, 2 и 4 байт соответсвенно;
      FLOAT, DOUBLE
         - число с плавающей точкой 4 и 8 байт соответственно;
      STRING
         - строка. В память записывается как <INT16,XXXX>.
           Т.е. первый байт - это длинна строки (без нуля на конце).
           При вычитывании строки программа- выделит память (char *),
           запишет в него строку и отдаст указатель на эту память;

   name
      - название данных. Это название после обработки попадёт в файл
        с аналогичным названием: <I2CMemory.h> и будет указывать на
        вычисленное смещение от начала памяти, например:
#define name 234
        Т.о. это определение можно будет затем использовать для
        получения значения в программе.
        Название может быть пропущено, в этом случае определения
        в файле <I2CMemory.h> не будет.
        Пропускать имя для главных данных нельзя, так-как в итоге к ним не будет доступа;

   <значение>
      - значение. Может содержать простые значения, массивы и объекты.
      Пример простых значений:
         CHAR CHAR_SINGN_WIN : 'B';
         INT8 : 255;
         INT16 : 65535;
         INT16 : -32767;
         DOUBLE : 3.1415926;
         STRING WIN_NAME : "Название машинки";

      {} - объект. Должен содержать значения внутри.
         При определении объекта тип не указываем, так-как внутренность
         объекта определяет его тип, например:
         OBJECT_VEHICLE : {
            INT8 : 255,
            DOUBLE : 60.78,
            STRING : "Быстрый мустанг"
         };
         Если объект находится внутри объекта или массива,
         то название можно опустить.

      [] - массив значений. Массив может содержать как простые значения,
           так и массивы и объекты. Для массивов определения типа - нет,
           но может быть определение типа для членов массива.
         Примеры:
         ARRAY_16_INTEGER : INT16[1,2,3,4];
         ARRAY_SOME_OBJECT : [{
            INT8 : 1,
            DOUBLE : 40.78,
            STRING : "Бегущий кабан"
         },{
            INT8 : 2,
            DOUBLE : 60.78,
            STRING : "Быстрый мустанг"
         },{
            INT8 : 3,
            DOUBLE : 120.78,
            STRING : "Плетущаяся черепаха"
         }];

 */
